
 <!DOCTYPE HTML>
<html lang="fr-FR">
<head>
  <meta charset="UTF-8">
  
    <title>Connectez votre rameur d&#39;appartement avec Chrome | Binomed Blog</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="jefBinomed">
    

    
    <meta name="description" content="Connectez votre rameur d’appartement avec ChromeWiiFit, AppleHealt, Google Fit, tout ça c’est du passé ! Place à SkiffSimulator !!
    

Nous allons voir à travers cet article comment réaliser un rame">
<meta property="og:type" content="article">
<meta property="og:title" content="Connectez votre rameur d'appartement avec Chrome">
<meta property="og:url" content="http://jef.binomed.fr/2015/10/30/2015-10-30--Connectez-votre-rameur-d-appartement-avec-Chrome/index.html">
<meta property="og:site_name" content="Binomed Blog">
<meta property="og:description" content="Connectez votre rameur d’appartement avec ChromeWiiFit, AppleHealt, Google Fit, tout ça c’est du passé ! Place à SkiffSimulator !!
    

Nous allons voir à travers cet article comment réaliser un rame">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/rameur_Accueil.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/schema_skiff.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/schema_bb.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/drawImage.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/A1_portrait.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/A2_portrait.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/A3_portrait.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/A4_portrait.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/A5_portrait.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/R1_portrait.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/R2_portrait.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/R3_portrait.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/R4_portrait.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/R5_portrait.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/rameur_Accueil.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/rameur_GameOver.png">
<meta property="og:image" content="http://jef.binomed.fr/assets/2015-10-Skiff/lego.jpg">
<meta property="og:updated_time" content="2016-02-26T15:02:46.773Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Connectez votre rameur d'appartement avec Chrome">
<meta name="twitter:description" content="Connectez votre rameur d’appartement avec ChromeWiiFit, AppleHealt, Google Fit, tout ça c’est du passé ! Place à SkiffSimulator !!
    

Nous allons voir à travers cet article comment réaliser un rame">
<meta name="twitter:creator" content="@jefBinomed">
<link rel="publisher" href="+JeanFrancoisGarreau">

    
    <link rel="alternative" href="/atom.xml" title="Binomed Blog" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/binomed_alizarin.png">
    <link rel="apple-touch-icon-precomposed" href="/img/binomed_alizarin.png">
    
    <link rel="stylesheet" href="/css/style.css" type="text/css">
</head>

  <body>
    <header>
      
	
	<div>
		
			<div id="imglogo">
				<a href="/"><img src="/img/binomed_alizarin.png" alt="Binomed Blog" title="Binomed Blog"/></a>
			</div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="Binomed Blog">Binomed Blog</a></h1>
				<h2 class="blog-motto">Encore un blog de G33k</h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Recherche" />
						<input type="hidden" name="q" value="site:jef.binomed.fr">
					</form>
					
					</li>
				</ul>
			</nav>			
	
</div>
    </header>
    <div id="container">
      <div id="main" class="post" itemscope itemprop="blogPost">
  
	<article itemprop="articleBody"> 
		<header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2015/10/30/2015-10-30--Connectez-votre-rameur-d-appartement-avec-Chrome/" title="Connectez votre rameur d&#39;appartement avec Chrome" itemprop="url">Connectez votre rameur d&#39;appartement avec Chrome</a>
  </h1>
  <p class="article-author">By
       
		<a href="https://plus.google.com/+JeanFrancoisGarreau?rel=author" title="jefBinomed" target="_blank" itemprop="author">jefBinomed</a>
		
  <p class="article-time">
    <time datetime="2015-10-30T15:36:24.000Z" itemprop="datePublished"> Publié 30 Oct 2015</time>
    
  </p>
</header>
	<div class="article-content">
		
		<h2 id="Connectez-votre-rameur-d’appartement-avec-Chrome"><a href="#Connectez-votre-rameur-d’appartement-avec-Chrome" class="headerlink" title="Connectez votre rameur d’appartement avec Chrome"></a>Connectez votre rameur d’appartement avec Chrome</h2><p>WiiFit, AppleHealt, Google Fit, tout ça c’est du passé ! Place à SkiffSimulator !!</p>
<div class="center"><br>    <img src="/assets/2015-10-Skiff/rameur_Accueil.png" class="center"><br></div>

<p>Nous allons voir à travers cet article comment réaliser un rameur connecté et ainsi vous permettre de vous amuser en faisant du sport ! </p>
<p>La version présentée dans cet article est une V1 dépendant d’un ordinateur. Il pourrait être très facile de faire évoluer l’application pour qu’elle soit autonome sur un équipement de type Raspberry par la suite.</p>
<h2 id="Principe"><a href="#Principe" class="headerlink" title="Principe"></a>Principe</h2><p>Grâce à l’<a href="https://developer.chrome.com/apps/serial" target="_blank" rel="external">API serial</a> de Google Chrome, nous allons relier directement notre rameur à notre navigateur pour créer un jeu qui nous permettra de jouer à un jeu 8bit. Voici globalement un schéma symbolisant le montage à effectuer : </p>
<p><img src="/assets/2015-10-Skiff/schema_skiff.png" alt=""></p>
<p>Nous allons faire communiquer 2 programmes entre eux : </p>
<ol>
<li>un sketch Arduino qui va mesurer la distance du joueur sur le rameur</li>
<li>une Application Chrome avec d’un côté :<br>a. la partie Chrome App qui va lire le port série<br>b. la partie Jeu qui va lire les informations provenant de la Chrome App</li>
</ol>
<p>Comme tout ceci n’est pas bien compliqué, j’ai décidé de tout coder from scratch afin de me faire la main sur les possibilités offertes par cet écosystème. Côté application web, nous avons un simple canvas afin de tirer parti de l’accélération matérielle. Côté matériel, j’ai opté un simple arduino avec un capteur ultrason.</p>
<h2 id="Shopping-List"><a href="#Shopping-List" class="headerlink" title="Shopping List"></a>Shopping List</h2><p>Voici les pré requis en terme d’achat pour réaliser cette démonstration : </p>
<ol>
<li>un rameur (~20€ sur le bon coin)</li>
<li>un Arduinio nano (~trouvé à 6€ sur tinyDeal)</li>
<li>une breadboard (~2€ sur tinyDeal)</li>
<li>un capteur ultrason HC-SR04(~1,5€ sur tinyDeal)</li>
<li>un fil MiniUSB -&gt; USB (fourni avec l’arduino)</li>
<li>des fils pour notre montage</li>
<li>un ordinateur avec Chrome</li>
</ol>
<h2 id="Un-jeu-en-HTML"><a href="#Un-jeu-en-HTML" class="headerlink" title="Un jeu en HTML ?"></a>Un jeu en HTML ?</h2><p>Avant de commencer, il m’a fallu me renseigner sur le fonctionnement d’un jeu et voir comment j’allais procéder pour respecter au mieux les bonnes pratiques en vigueur. </p>
<p>Globalement, un jeu possède plusieurs briques qui fonctionnent en parallèle afin de minimiser le blocage de l’UI. Pour rappel, un jeu est considéré comme fluide s’il est à 60fps ce qui veut dire que chaque affichage ne doit pas dépasser les 13ms. Afin de respecter au mieux cette contrainte, j’ai découpé mon programme : </p>
<ul>
<li>la brique qui s’occupe de l’affichage va lire dans un modèle partagé</li>
<li>la brique qui s’occupe de lire les données de l’arduino va alimenter ce modèle partagé et faire les calculs nécessaires</li>
</ul>
<p>De cette façon, j’ai une séparation propre de mes interactions et des actions provenant de l’extérieur pouvant parfois bloquer mon interface. Il est à noter qu’avec ce fonctionnement, je tolère une désyncrhonisation entre l’état de mon modèle et mon affichage. Je pars du principe que celle-ci sera de maximum 13ms, ce qui est acceptable.</p>
<h2 id="Sketch-Arduino"><a href="#Sketch-Arduino" class="headerlink" title="Sketch Arduino"></a>Sketch Arduino</h2><p><img src="/assets/2015-10-Skiff/schema_bb.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Pour le cpateur à ultrasons</span></span><br><span class="line"><span class="keyword">int</span> TriggerPin = <span class="number">8</span>; </span><br><span class="line"><span class="comment">//Trig pin</span></span><br><span class="line"><span class="keyword">int</span> EchoPin = <span class="number">5</span>; </span><br><span class="line"><span class="comment">//Echo pin</span></span><br><span class="line"><span class="keyword">long</span> distance; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setup</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   Serial.begin(<span class="number">9600</span>); </span><br><span class="line">   <span class="comment">//Mise en entrées de Pins</span></span><br><span class="line">   <span class="comment">//On initialise le capteur à ultrasons</span></span><br><span class="line">   pinMode(TriggerPin, OUTPUT); </span><br><span class="line">   digitalWrite(TriggerPin, LOW); </span><br><span class="line">   pinMode(EchoPin, INPUT); </span><br><span class="line">   delay(<span class="number">100</span>); </span><br><span class="line">   Serial.println(<span class="string">"Fin SETUP capteurs"</span>); </span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   distance = lire_distance(); </span><br><span class="line">   Serial.print(<span class="string">"D"</span>); </span><br><span class="line">   Serial.println(distance); </span><br><span class="line">   <span class="comment">//Envoi des données en BT : </span></span><br><span class="line">   delay(<span class="number">50</span>); </span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">lire_distance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">long</span> lecture_echo; </span><br><span class="line">   digitalWrite(TriggerPin, HIGH); </span><br><span class="line">   delayMicroseconds(<span class="number">10</span>); </span><br><span class="line">   digitalWrite(TriggerPin, LOW); </span><br><span class="line">   lecture_echo = pulseIn(EchoPin, HIGH); </span><br><span class="line">   <span class="keyword">long</span> cm = lecture_echo / <span class="number">58</span>; </span><br><span class="line">   <span class="keyword">return</span>(cm); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Le fonctionnement est très simple : il suffit de lire la mesure de distance dès que l’on en obtient une, puis on la retranscrit directement sur le port série.</p>
<h2 id="ChromeApp"><a href="#ChromeApp" class="headerlink" title="ChromeApp ?"></a>ChromeApp ?</h2><p>Comme il s’agit d’une application chrome, nous devons créer un fichier <a href="https://developer.chrome.com/extensions/manifest" target="_blank" rel="external">manifest.json</a> :  <a href="https://github.com/sqli-nantes/skiff-simulator/blob/master/chromeApp%2Fmanifest.json" target="_blank" rel="external">Manifest de SkiffSumulator</a> qui correspond au fichier de configuration de l’application chrome. </p>
<h3 id="Structure-de-l’application"><a href="#Structure-de-l’application" class="headerlink" title="Structure de l’application"></a>Structure de l’application</h3><p>L’application possède donc plusieurs scripts qui vont tourner en parallèle afin de faire fonctionner le jeu. Voici la structure de mon projet côté application web : </p>
<ul>
<li>assets : répertoire possèdant tous les fichiers de ressources du jeu (Fonts, images, sons)</li>
<li>javascript : ensemble des srcipts javascript constituant l’application</li>
<li>scss : fichier sass qui vont servir à générer le css</li>
</ul>
<p>Nous allons nous attarder uniquement sur les scripts car c’est dans cette partie que se situe toute l’intelligence du jeu. En effet, le fichier html est très sommaire car il ne contient qu’un canvas : </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="doctype">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">lang</span>=<span class="value">"en"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">meta</span> <span class="attribute">charset</span>=<span class="value">"UTF-8"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">title</span>&gt;</span>Skiff Almost Simulator<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"icon"</span> <span class="attribute">type</span>=<span class="value">"image/png"</span> <span class="attribute">href</span>=<span class="value">"./assets/images/icon48.png"</span> /&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span><span class="value">href=".</span>/<span class="attribute">css</span>/<span class="attribute">app.css</span>"/&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">canvas</span> <span class="attribute">id</span>=<span class="value">"skiff"</span>&gt;</span><span class="tag">&lt;/<span class="title">canvas</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">input</span> <span class="attribute">id</span>=<span class="value">"user"</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">placeholder</span>=<span class="value">'Enter your name'</span>/&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./javascript/resources.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./javascript/audio.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./javascript/const.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./javascript/chrome_storage.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./javascript/chrome_serial.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./javascript/screen_accueil.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./javascript/screen_action.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./javascript/screen_end.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"./javascript/app.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="Scripts-et-roles"><a href="#Scripts-et-roles" class="headerlink" title="Scripts et rôles"></a>Scripts et rôles</h3><p>Voici les différents fichiers et leur rôles : </p>
<ul>
<li>app.js : coeur de l’application, il s’agit du point d’entrée de l’application et il agit comme un chef d’orchestre. C’est dans un sens le contrôleur de notre application</li>
<li>audio.js : fichier servant à gérer la lecture des fichiers audio</li>
<li>chrome_serial.js : fichier contenant le code spécifique à Chrome qui va nous permettre de lire directement depuis le port série de l’ordinateur</li>
<li>chrome_storage.js : fichier utilitaire qui expose de façon uniforme une API de localstorage au cas où l’application devrait tourner en dehors de Chrome (plus de détails plus loin dans l’article)</li>
<li>const.js : fichier regroupant toutes les constantes du jeu. Il peut s’agir de simples constantes ou de variables d’ajustement servant lors de la calibration du jeu</li>
<li>ressources.js : fichier permettant d’exposer un mécanisme de chargement de ressources graphiques en vue de les exploiter par la suite dans le programme</li>
<li>screen_acceuil.js : fichier contenant tout le code spécifique à l’affichage de l’écran d’accueil</li>
<li>screen_action.js : fichier contenant tout le code spécifique à l’affichage pendant le jeu</li>
<li>screen_end.js : fichier contenant tout le code spécifique à l’affiche de l’écran de fin</li>
</ul>
<p>Le <a href="https://carldanley.com/js-revealing-module-pattern/" target="_blank" rel="external">Reveal Module Pattern</a> a été choisi comme pattern car il permet de fonctionner en module javascript et d’offrir un découpage propre du code tout en maîtrisant les méthodes exposées.</p>
<h2 id="Deroulement-du-programme"><a href="#Deroulement-du-programme" class="headerlink" title="Déroulement du programme :"></a>Déroulement du programme :</h2><p>Prenons les différents points méritant de l’attention : </p>
<h3 id="Demarage-App-js"><a href="#Demarage-App-js" class="headerlink" title="Démarage (App.js)"></a>Démarage (App.js)</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//API</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">init</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="built_in">window</span>.addEventListener(<span class="string">'load'</span>, </span><br><span class="line">   pageLoad); </span><br><span class="line">   &#125;</span><br><span class="line"><span class="keyword">return</span> &#123;</span><br><span class="line">   init : init, ... &#125;</span><br><span class="line">&#125;</span><br><span class="line">(); </span><br><span class="line">AppSAS.init();</span><br></pre></td></tr></table></figure>
<p>On démarre l’application dès que la page est prête.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="pi">'use strict'</span>; </span><br><span class="line"><span class="keyword">var</span> AppSAS = AppSAS || <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   … <span class="function"><span class="keyword">function</span> <span class="title">pageLoad</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="comment">// On se connecte à l'arduino</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">         skiffSimulatorChrome.initArduino(); </span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">         <span class="built_in">console</span>.error(<span class="string">"Error : %s \n %s"</span>, </span><br><span class="line">         err.message, err.stack); </span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p>On doit faire appel au module qui va lire les données de l’arduino.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// On initialise le canvas</span></span><br><span class="line">ui.input = <span class="built_in">document</span>.getElementById(<span class="string">'user'</span>); </span><br><span class="line">ui.canvas = <span class="built_in">document</span>.getElementById(<span class="string">'skiff'</span>); </span><br><span class="line">ui.canvas.width = <span class="built_in">window</span>.innerWidth; </span><br><span class="line">ui.canvas.height = <span class="built_in">window</span>.innerHeight; </span><br><span class="line">ui.context = ui.canvas.getContext(<span class="string">'2d'</span>); </span><br><span class="line">ui.canvas.addEventListener(<span class="string">'click'</span>, checkClick, <span class="literal">false</span>); </span><br><span class="line"><span class="comment">// On précharge toutes les ressources nécessaires</span></span><br><span class="line">ui.resources.loadSprites([ &#123;</span><br><span class="line">   title : <span class="string">'logo'</span>, url : <span class="string">'assets/images/logo.png'</span>&#125;</span><br><span class="line">, &#123;</span><br><span class="line">   title : <span class="string">'game_over'</span>, url : <span class="string">'assets/images/gameover.png'</span>&#125;</span><br><span class="line">, &#123;</span><br><span class="line">   title : <span class="string">'rive_gauche_portrait'</span>, url : <span class="string">'assets/images/riviere_gauche_portrait.png'</span>&#125;</span><br><span class="line">, ... ]) .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">   paintSkiff(); </span><br><span class="line">   &#125;</span><br><span class="line">).catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">   <span class="built_in">console</span>.error(<span class="string">"Error : %s \n %s"</span>, err.message, err.stack); &#125;</span><br><span class="line">); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>On initialise notre canvas ainsi que les ressources graphiques du projet. On n’affiche le jeu qu’une fois ces dernières chargées.</p>
<h3 id="En-fonctionnement-app-js"><a href="#En-fonctionnement-app-js" class="headerlink" title="En fonctionnement (app.js)"></a>En fonctionnement (app.js)</h3><p>Une fois l’application réellement démarrée avec la méthode paintSkiff. Nous allons simplement déléguer l’affichage aux méthodes appropriées : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Gère l'affichage de l'écran</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintSkiff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      ... <span class="comment">// Affichage des décors</span></span><br><span class="line">      paintBackground(); </span><br><span class="line">      <span class="keyword">if</span> (gameModel.stateGame === constState.STATE_ACCUEIL) &#123;</span><br><span class="line">         ScreenSasAccueil.paintSkiffAccueil(); </span><br><span class="line">         StorageSAS.manageGhost(); </span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (gameModel.stateGame === constState.STATE_RUNNING) &#123;</span><br><span class="line">         <span class="comment">// On doit peindre le fantome du jeu en deuxième car son alpha nous indique où il est</span></span><br><span class="line">         ScreenSasAction.paintSkiffAction(); </span><br><span class="line">         ScreenSasAction.paintSkiffGhost(); </span><br><span class="line">         <span class="comment">// On ajoute l'état à l'historique</span></span><br><span class="line">         gameModel.currentHistory.push( &#123;</span><br><span class="line">            direction : gameModel.direction, </span><br><span class="line">            distanceSkiff : + gameModel.distanceSkiff, </span><br><span class="line">            distanceArduino : + gameModel.distanceArduino &#125;</span><br><span class="line">         ); </span><br><span class="line">         gameModel.step++; </span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">if</span> (gameModel.stateGame === constState.STATE_END) &#123;</span><br><span class="line">         ScreenSasEnd.paintSkiffEnd(); </span><br><span class="line">         &#125;</span><br><span class="line">      <span class="built_in">window</span>.requestAnimationFrame(paintSkiff); </span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">      <span class="built_in">console</span>.error(<span class="string">"Error : %s \n %s"</span>, </span><br><span class="line">      err.message, err.stack); </span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Il est à noter que l’on utilise la méthode window.requestAnimtionFrame. Cette dernière est très importante car elle permet d’optimiser l’affichage de nos écrans en fonction de la puissance de la machine. En effet, la méthode de callback ne sera appelée une fois le navigateur prêt à effectuer une nouvelle mise à jour graphique. Il faut donc utiliser cette méthode à la place d’un setInterval</p>
<h3 id="Affichage-des-ecrans"><a href="#Affichage-des-ecrans" class="headerlink" title="Affichage des écrans"></a>Affichage des écrans</h3><p>L’affichage des écrans se fait toujours de la même façon : </p>
<ol>
<li>on nettoie le canvas</li>
<li>on dessine une ou des images sur le canvas</li>
</ol>
<p>L’affichage d’un écran se fait toujours de la façon suivante : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">ui.context.drawImage(imgSource <span class="comment">//L’image source</span></span><br><span class="line">, sx <span class="comment">//sx clipping de l'image originale</span></span><br><span class="line">, sy <span class="comment">//sy clipping de l'image originale</span></span><br><span class="line">, sw <span class="comment">// swidth clipping de l'image originale</span></span><br><span class="line">, sh <span class="comment">// sheight clipping de l'image originale</span></span><br><span class="line">, dx <span class="comment">// x Coordonnées dans le dessin du canvas</span></span><br><span class="line">, dy <span class="comment">// y Coordonnées dans le dessing du canvas</span></span><br><span class="line">, dw <span class="comment">// width taille du dessin</span></span><br><span class="line">, dh <span class="comment">// height taille du dessin </span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<div class="center"><br>    <img src="/assets/2015-10-Skiff/drawImage.png" class="center"><br></div>

<p>Les animations / constructions des écrans ne sont en fait qu’une succession de drawImage ou fillText.</p>
<h3 id="Gestion-des-interactions"><a href="#Gestion-des-interactions" class="headerlink" title="Gestion des interactions"></a>Gestion des interactions</h3><p>Afin de pouvoir démarrer l’application, nous devons gérer les clicks sur le canvas. Le problème est que lorsque nous dessinons des images, nous ne pouvons pas avoir accès à un équivalent de onClick sur une zone graphique précise. Nous devons donc écouter les clicks sur le canvas et calculer si la zone de click correspond à une zone d’interaction de notre ihm.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">    <span class="comment">// Gère les clicks en fonction de l'état du jeu</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">checkClick</span>(<span class="params">event</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (gameModel.stateGame != constState.STATE_RUNNING) &#123;</span><br><span class="line">      <span class="keyword">var</span> btnStart = ui.resources.images[<span class="string">'btn_start'</span>]; </span><br><span class="line">      <span class="keyword">var</span> finalHeight = btnStart.height * ui.ratio, </span><br><span class="line">      finalWidth = btnStart.width * ui.ratio; </span><br><span class="line">      <span class="keyword">var</span> x = (ui.canvas.width / <span class="number">2</span>) - ((btnStart.width * ui.ratio) / <span class="number">2</span>), y = ui.canvas.height - finalHeight - (isPortrait() ? <span class="number">100</span> : <span class="number">50</span>);</span><br><span class="line">      <span class="keyword">var</span> xClick = event.pageX, </span><br><span class="line">      yClick = event.pageY; </span><br><span class="line">      <span class="keyword">if</span> (yClick &gt; y &amp;&amp; yClick &lt; (y + finalHeight) &amp;&amp; xClick &gt; x &amp;&amp; xClick &lt; (x + finalWidth)) &#123;</span><br><span class="line">         <span class="comment">// On change l'état du jeu</span></span><br><span class="line">         gameModel.stateGame = gameModel.stateGame === constState.STATE_ACCUEIL ? constState.STATE_RUNNING : constState.STATE_ACCUEIL; </span><br><span class="line">        ... </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Gestion-du-moteur"><a href="#Gestion-du-moteur" class="headerlink" title="Gestion du moteur"></a>Gestion du moteur</h3><p>Un des éléments clés du programme est l’alimentation du modèle depuis l’application chrome. L’application chrome va alimenter le modèle et déterminer un certain nombre d’éléments en lien avec le rendu souhaité, puis appeler le moteur de calcul pour terminer les traitements. On vérifie par exemple dans quel sens va le joueur, s’il y a eu un déplacement, etc.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Calcul </span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setDistance</span>(<span class="params">distance</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (gameModel.distanceArduino === distance) &#123;</span><br><span class="line">      gameModel.direction = <span class="number">0</span>; </span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span> (gameModel.distanceArduino &gt; distance) &#123;</span><br><span class="line">      gameModel.direction = <span class="number">1</span>; </span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      gameModel.direction = - <span class="number">1</span>; </span><br><span class="line">      &#125;</span><br><span class="line">   <span class="comment">// Vitesse en cm / ms</span></span><br><span class="line">   <span class="keyword">var</span> deltaCM = <span class="built_in">Math</span>.abs(gameModel.distanceArduino - distance); </span><br><span class="line">   <span class="keyword">if</span> (deltaCM &gt; ConstSAS.MIN_DELTA_CM) &#123;</span><br><span class="line">      gameModel.speed = deltaCM / ConstSAS.DELAY; </span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">else</span> &#123;</span><br><span class="line">      gameModel.speed = <span class="built_in">Math</span>.max(gameModel.speed - ConstSAS.FACTOR_SPEED, </span><br><span class="line">      <span class="number">0</span>); </span><br><span class="line">      &#125;</span><br><span class="line">   gameModel.distanceArduino = distance; </span><br><span class="line">   engineSkiff(); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Le coeur du moteur quant à lui, s’occupe uniquement de lire les données issues de l’arduino et de calculer la distance globale parcourue, ainsi que le pourcentage de déplacements dans l’écran.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">engineSkiff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (gameModel.speed &gt; <span class="number">0</span> &amp;&amp; gameModel.stateGame === constState.STATE_RUNNING) &#123;</span><br><span class="line">      <span class="keyword">var</span> distanceSpeed = gameModel.speed * ConstSAS.DELAY; </span><br><span class="line">      <span class="comment">// On incrémente la distance</span></span><br><span class="line">      gameModel.distanceSkiff += (distanceSpeed * ConstSAS.FACTOR_DISTANCE); </span><br><span class="line">      <span class="comment">// On gère l'effet de déplacement des bords via un pourcentage</span></span><br><span class="line">      gameModel.percent = (gameModel.distanceSkiff % <span class="number">100</span>) / <span class="number">100</span>;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Specifique-Chrome"><a href="#Specifique-Chrome" class="headerlink" title="Spécifique Chrome"></a>Spécifique Chrome</h2><p>Depuis le début nous parlons d’application chrome et de l’API Serial, il est désormais temps de voir comment nous implémentons cette partie.</p>
<h3 id="Interaction-avec-l’Arduino"><a href="#Interaction-avec-l’Arduino" class="headerlink" title="Interaction avec l’Arduino"></a>Interaction avec l’Arduino</h3><p>Toute l’interaction avec L’arduino se fait directement via le port série. Mais il faut pour cela passer par des étapes clés : </p>
<ol>
<li>récupérer les appareils connectés sur les ports série “chrome.serial.getDevices”</li>
<li>une fois un appareil trouvé, on s’y connecte “chrome.serial.connect”. Dans notre exemple, on veille à ce qu’il n’y ai qu’un appareil de connecté au moment du lancement de l’application</li>
<li>lire le port série “chrome.serial.onReceive”</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initArduino</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   chrome.serial.getDevices(<span class="function"><span class="keyword">function</span>(<span class="params">ports</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (ports &amp;&amp; ports.length == <span class="number">1</span>) &#123;</span><br><span class="line">         chrome.serial.connect(ports[<span class="number">0</span>].path, </span><br><span class="line">         onOpenArduino); </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   ); </span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onOpenArduino</span>(<span class="params">openInfo</span>) </span>&#123;</span><br><span class="line">   connectionId = openInfo.connectionId; </span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">"connectionId: "</span> + connectionId); </span><br><span class="line">   <span class="keyword">if</span> (connectionId == - <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'Could not open'</span>); </span><br><span class="line">      <span class="keyword">return</span>; </span><br><span class="line">      &#125;</span><br><span class="line">   <span class="built_in">console</span>.log(<span class="string">'Connected'</span>); </span><br><span class="line">   chrome.serial.onReceive.addListener(onReadArduino); </span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">convertArrayBufferToString</span>(<span class="params">buf</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="built_in">String</span>.fromCharCode.apply(<span class="literal">null</span>, </span><br><span class="line">   <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buf)); </span><br><span class="line">   &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">onReadArduino</span>(<span class="params">readInfo</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (readInfo.connectionId == connectionId &amp;&amp; readInfo.data) &#123;</span><br><span class="line">      <span class="keyword">var</span> str = convertArrayBufferToString(readInfo.data); </span><br><span class="line">      <span class="keyword">if</span> (str.charAt(str.length - <span class="number">1</span>) === <span class="string">'\n'</span>) &#123;</span><br><span class="line">         value += str.substring(<span class="number">0</span>, </span><br><span class="line">         str.length - <span class="number">1</span>); </span><br><span class="line">         <span class="keyword">if</span> (regExp.test(value)) <span class="comment">// Light on and off</span></span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">var</span> distanceTmp = + regExp.exec(value)[<span class="number">1</span>]; </span><br><span class="line">            <span class="keyword">if</span> (distanceTmp &lt; ConstSAS.DISTANCE_MAX &amp;&amp; <span class="built_in">Math</span>.abs(distance - distanceTmp) &lt; (ConstSAS.DISTANCE_MAX * <span class="number">1.5</span>) ) &#123;</span><br><span class="line">               AppSAS.setDistance(distanceTmp); </span><br><span class="line">               &#125;</span><br><span class="line">            distance = distanceTmp; </span><br><span class="line">            &#125;</span><br><span class="line">         value = <span class="string">""</span>; </span><br><span class="line">         &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">         value += str; </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Il faut noter une petite particularité lors de la lecture : nous lisons le port série et nous attendons une chaîne de caractères. Aussi, il est important de penser à convertir les données issues du port série en données exploitables sous forme de chaîne de caractères.</p>
<h2 id="Gestion-des-ecrans-et-cas-particuliers"><a href="#Gestion-des-ecrans-et-cas-particuliers" class="headerlink" title="Gestion des écrans et cas particuliers"></a>Gestion des écrans et cas particuliers</h2><p>Maintenant que nous avons vu la mécanique sous le capot, regardons de plus près quelques cas particuliers qui méritent un peu d’attention.</p>
<h3 id="Deplacement-du-decor"><a href="#Deplacement-du-decor" class="headerlink" title="Déplacement du décor"></a>Déplacement du décor</h3><p>Afin de donner une sensation de déplacement, il nous faut bouger nos rives. Pour se faire, on va simplement fonctionner avec un indicateur en pourcentage en rapport avec le déplacement global du rameur. Ainsi pour afficher correctement nos 2 rives qui bougent, il nous suffit juste de dessiner 2 fois chaque rive de chaque côté afin de gérer les dépassement d’écran et de les positionner en fonction d’un pourcentage résultant d’un modulo de la distance du rameur : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Affiche le rivage en fonction de la rive souhaitée et de la progression du rameur</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintRive</span>(<span class="params">riveDroite</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> rive = ui.resources.images[(riveDroite ? <span class="string">'rive_droite'</span> : <span class="string">'rive_gauche'</span>) + getSuffix()]; </span><br><span class="line">   <span class="keyword">var</span> finalHeight = rive.height * ui.ratio, </span><br><span class="line">   finalWidth = rive.width * ui.ratio; </span><br><span class="line">   ui.context.drawImage(rive , <span class="number">0</span> <span class="comment">//sx clipping de l'image originale</span></span><br><span class="line">   , <span class="number">0</span> <span class="comment">//sy clipping de l'image originale</span></span><br><span class="line">   , rive.width <span class="comment">// swidth clipping de l'image originale</span></span><br><span class="line">   , rive.height <span class="comment">// sheight clipping de l'image originale</span></span><br><span class="line">   , riveDroite ? ui.canvas.width - finalWidth : <span class="number">0</span> <span class="comment">// x Coordonnées dans le dessing du canvas</span></span><br><span class="line">   , <span class="number">0</span> - (finalHeight * gameModel.percent) <span class="comment">// y Coordonnées dans le dessing du canvas</span></span><br><span class="line">   , finalWidth <span class="comment">// width taille du dessin</span></span><br><span class="line">   , finalHeight <span class="comment">// height taille du dessin </span></span><br><span class="line">   ); </span><br><span class="line">   ui.context.drawImage(rive , <span class="number">0</span> <span class="comment">//sx clipping de l'image originale</span></span><br><span class="line">   , <span class="number">0</span> <span class="comment">//sy clipping de l'image originale</span></span><br><span class="line">   , rive.width <span class="comment">// swidth clipping de l'image originale</span></span><br><span class="line">   , rive.height <span class="comment">// sheight clipping de l'image originale</span></span><br><span class="line">   , riveDroite ? ui.canvas.width - finalWidth : <span class="number">0</span> <span class="comment">// x Coordonnées dans le dessing du ui.canvas</span></span><br><span class="line">   , finalHeight - (finalHeight * gameModel.percent) <span class="comment">// y Coordonnées dans le dessing du canvas</span></span><br><span class="line">   , finalWidth <span class="comment">// width taille du dessin</span></span><br><span class="line">   , finalHeight <span class="comment">// height taille du dessin </span></span><br><span class="line">   ); </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="L’affichage-du-rameur"><a href="#L’affichage-du-rameur" class="headerlink" title="L’affichage du rameur"></a>L’affichage du rameur</h3><p>L’affichage du rameur comporte 2 parties à prendre en compte : </p>
<ol>
<li>l’affichage du rameur en fonction de la position du joueur</li>
<li>l’avancée du rameur quand le mode ghost est activé</li>
</ol>
<h4 id="Position-du-rameur-en-fonction-du-joueur"><a href="#Position-du-rameur-en-fonction-du-joueur" class="headerlink" title="Position du rameur en fonction du joueur"></a>Position du rameur en fonction du joueur</h4><p>Afin de restituer au mieux les gestes effectués par le joueur, il a fallu réfléchir à une façon d’afficher la bonne image de rameur, en fonction de sa position sur le rameur.</p>
<div><br><img src="/assets/2015-10-Skiff/A1_portrait.png" class="imgskiff"><img src="/assets/2015-10-Skiff/A2_portrait.png" class="imgskiff"><img src="/assets/2015-10-Skiff/A3_portrait.png" class="imgskiff"><img src="/assets/2015-10-Skiff/A4_portrait.png" class="imgskiff"><img src="/assets/2015-10-Skiff/A5_portrait.png" class="imgskiff"><img src="/assets/2015-10-Skiff/R1_portrait.png" class="imgskiff"><img src="/assets/2015-10-Skiff/R2_portrait.png" class="imgskiff"><img src="/assets/2015-10-Skiff/R3_portrait.png" class="imgskiff"><img src="/assets/2015-10-Skiff/R4_portrait.png" class="imgskiff"><img src="/assets/2015-10-Skiff/R5_portrait.png" class="imgskiff"><br></div>

<div style="clear:both"></div>

<p> La réponse était relativement simple :  il suffit de connaître à chaque instant la position du joueur sur le rameur et sa direction, puis d’appliquer la bonne image.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">indexToUse</span>(<span class="params">direction, distance</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> arrayToUse = direction &gt;= <span class="number">0</span> ? mappingPositonRameurFront : mappingPositonRameurBack; </span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrayToUse.length; i++) &#123;</span><br><span class="line">      <span class="keyword">var</span> minMax = arrayToUse[i]; </span><br><span class="line">      <span class="keyword">if</span> (distance &gt; minMax.min &amp;&amp; distance &lt;= minMax.max) &#123;</span><br><span class="line">         <span class="keyword">return</span> minMax.indexSprite + AppSAS.getSuffix(); </span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   <span class="keyword">return</span> mappingPositonRameurBack[<span class="number">0</span>].indexSprite + AppSAS.getSuffix(); </span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// Affiche le bon sprire du bateau</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintBoat</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">//var ratio = 0.05;</span></span><br><span class="line">   <span class="keyword">var</span> image = AppSAS.ui.resources.images[AppSAS.gameModel.indexSprite]; </span><br><span class="line">   AppSAS.ui.context.shadowOffsetX = <span class="number">0</span>; </span><br><span class="line">   AppSAS.ui.context.shadowOffsetY = <span class="number">0</span>; </span><br><span class="line">   AppSAS.ui.context.shadowBlur = <span class="number">0</span>; </span><br><span class="line">   AppSAS.ui.context.drawImage(image , <span class="number">0</span> <span class="comment">//sx clipping de l'image originale</span></span><br><span class="line">   , <span class="number">0</span> <span class="comment">//sy clipping de l'image originale</span></span><br><span class="line">   , image.width <span class="comment">// swidth clipping de l'image originale</span></span><br><span class="line">   , image.height <span class="comment">// sheight clipping de l'image originale</span></span><br><span class="line">   , (AppSAS.ui.canvas.width / <span class="number">2</span>) - ((image.width * AppSAS.ui.ratio) / <span class="number">2</span>) <span class="comment">// x Coordonnées dans le dessin du AppSAS.ui.canvas </span></span><br><span class="line">   , (AppSAS.ui.canvas.height / <span class="number">2</span>) - ((image.height * AppSAS.ui.ratio) / <span class="number">2</span>) + <span class="number">100</span><span class="comment">// y Coordonnées dans le dessin du AppSAS.ui.canvas </span></span><br><span class="line">   , image.width * AppSAS.ui.ratio <span class="comment">// width taille du dessin </span></span><br><span class="line">   , image.height * AppSAS.ui.ratio <span class="comment">// height taille du dessin  </span></span><br><span class="line">) &#125;</span><br></pre></td></tr></table></figure>
<p>De cette manière nous affichons toujours la bonne image. Puis, afin de faciliter le déplacement du bateau, il a été considéré qu’il était en position fixe sur l’écran et que l’illusion du déplacement se fait uniquement à travers le déplacement du décor.</p>
<h4 id="Gestion-du-ghost"><a href="#Gestion-du-ghost" class="headerlink" title="Gestion du ghost"></a>Gestion du ghost</h4><p>L’affichage du ghost doit faire face à un problème. Contrairement au bateau, ce dernier se déplace sur l’écran. Le problème est que ce déplacement vient surtout du fait qu’il a fallu gérer le cas d’un ghost allant plus vite que le joueur courant. En effet, si le ghost est meilleur que le joueur, alors, il sera vers le haut de l’écran ce qui veut dire que sa position va s’approcher de l’axe, voire aller dans les négatifs. Or dans un canvas, si un élément est dessiné avec des coordonnées de destination dans le négatif, l’élément n’est tout simplement pas peint !  Il a donc fallu tronquer l’image source pour donner l’illusion que le dessin du ghost parte vers le haut de l’écran.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Affiche le bon sprire du bateau du mode Ghost</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">paintGhost</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">   <span class="comment">//var ratio = 0.05;</span></span><br><span class="line">   <span class="keyword">var</span> image = AppSAS.ui.resources.images[AppSAS.gameModel.indexSpriteGhost]; </span><br><span class="line">   ...</span><br><span class="line">   <span class="comment">// Le fantome doit etre dessiné là où il est au niveau de sa distance globale par rapport au bateau actuel </span></span><br><span class="line">   <span class="comment">// =&gt; On l'affiche là où est son delta en distance par rapport à bateau actuel</span></span><br><span class="line">   <span class="keyword">var</span> stateGhost = AppSAS.gameModel.ghost[AppSAS.gameModel.step]; </span><br><span class="line">   <span class="keyword">var</span> deltaGhost = AppSAS.gameModel.distanceSkiff - stateGhost.distanceSkiff; </span><br><span class="line">   <span class="comment">// On doit tronquer le ghost s'il dépasse de l'écran </span></span><br><span class="line">   <span class="keyword">var</span> yGhost = (AppSAS.ui.canvas.height / <span class="number">2</span>) - ((image.height * AppSAS.ui.ratio) / <span class="number">2</span>) + <span class="number">100</span> + (deltaGhost * ConstSAS.FACTOR_GHOST);</span><br><span class="line">   <span class="keyword">var</span> heightSpriteGhost = image.height; </span><br><span class="line">   <span class="keyword">if</span> (yGhost &lt; <span class="number">0</span>) &#123;</span><br><span class="line">      heightSpriteGhost = image.height + yGhost; </span><br><span class="line">      yGhost = <span class="number">0</span>; </span><br><span class="line">      &#125;</span><br><span class="line">   AppSAS.ui.context.drawImage(image , <span class="number">0</span> <span class="comment">//sx clipping de l'image originale</span></span><br><span class="line">   , image.height - heightSpriteGhost <span class="comment">//sy clipping de l'image originale</span></span><br><span class="line">   , image.width <span class="comment">// swidth clipping de l'image originale</span></span><br><span class="line">   , heightSpriteGhost <span class="comment">// sheight clipping de l'image originale</span></span><br><span class="line">   , (AppSAS.ui.canvas.width / <span class="number">2</span>) - ((image.width * AppSAS.ui.ratio) / <span class="number">2</span>) <span class="comment">// x Coordonnées dans le dessin du AppSAS.ui.canvas </span></span><br><span class="line">   , yGhost <span class="comment">// y Coordonnées dans le dessin du AppSAS.ui.canvas , image.width * AppSAS.ui.ratio // width taille du dessin </span></span><br><span class="line">   , heightSpriteGhost * AppSAS.ui.ratio <span class="comment">// height taille du dessin </span></span><br><span class="line">   );</span><br><span class="line">   ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="Affichage-des-ecrans-de-login-amp-de-scores"><a href="#Affichage-des-ecrans-de-login-amp-de-scores" class="headerlink" title="Affichage des écrans de login &amp; de scores"></a>Affichage des écrans de login &amp; de scores</h3><p>Ces 2 écrans sont différents car on y affiche non pas une animation, mais tu texte.</p>
<h4 id="Ecran-de-Login"><a href="#Ecran-de-Login" class="headerlink" title="Ecran de Login"></a>Ecran de Login</h4><div class="center"><br>    <img src="/assets/2015-10-Skiff/rameur_Accueil.png" class="center"><br></div>

<p>Concernant l’écran de login, il n’existe pas d’équivalent du champ input dans un canvas. Aussi, il a fallu intégrer à notre html une balise input que l’on affiche ou cache en fonction du besoin.</p>
<h4 id="Ecran-de-scores"><a href="#Ecran-de-scores" class="headerlink" title="Ecran de scores"></a>Ecran de scores</h4><div class="center"><br>    <img src="/assets/2015-10-Skiff/rameur_GameOver.png" class="center"><br></div>

<p>L’affichage du score est simple car il ne s’agit que d’afficher du texte : </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">AppSAS.ui.context.fillText(MyText, x, y);</span><br></pre></td></tr></table></figure>
<p>La taille et la couleur du texte sont définis par des propriétés appliquées directement sur le context du canvas.</p>
<h3 id="Persistance-des-donnees"><a href="#Persistance-des-donnees" class="headerlink" title="Persistance des données"></a>Persistance des données</h3><p>Pour sauvegarder les données d’une partie à l’autre, ou même d’un démarrage d’application à l’autre. J’ai fait le choix le plus simple : le LocalStorage. Le seul hic avec le LocalStorage et les ChromeApps, c’est que l’API telle qu’elle est disponible en html5 n’existe pas sur une ChromeApp. En effet, l’api localStorage étant syncrhone, Google a préféré mettre en place une solution asyncrhone : <a href="https://developer.chrome.com/apps/storage" target="_blank" rel="external">https://developer.chrome.com/apps/storage</a>. J’ai donc mis en place la solution de Google et j’en ai profité pour prévoir une api uniforme entre localstorage &amp; chrome.storage au cas où vous partiriez sur une solution native html5.</p>
<h3 id="Placer-l’aduino"><a href="#Placer-l’aduino" class="headerlink" title="Placer l’aduino"></a>Placer l’aduino</h3><p>Afin de mesurer au mieux les données de distance, j’ai placé l’arduino au dos de l’utilisateur et j’ai fabriqué une petite boîte pour packager un peu tout ça :</p>
<p><img src="/assets/2015-10-Skiff/lego.jpg" alt=""></p>
<h2 id="Annexes"><a href="#Annexes" class="headerlink" title="Annexes"></a>Annexes</h2><p>Le code complet est disponible <a href="https://github.com/sqli-nantes/skiff-simulator" target="_blank" rel="external">https://github.com/sqli-nantes/skiff-simulator</a></p>
<script type="text/javascript" src="/assets/js_helper/jef-binomed-helper.js"></script>
<script type="text/javascript" src="/assets/2015-10-Skiff/skiff-custo.js"></script>
  
	</div>
		<footer class="article-footer clearfix">
<div class="article-catetags">

  <div class="article-tags">
  
  <span></span> <a href="/tags/Arduino/">Arduino</a><a href="/tags/Canvas/">Canvas</a><a href="/tags/Chrome/">Chrome</a><a href="/tags/HTML5/">HTML5</a><a href="/tags/Jeux/">Jeux</a>
  </div>


<div class="article-categories">
  <span></span>
  <a class="article-category-link" href="/categories/Tech/">Tech</a>
</div>

</div>



	<div class="article-share" id="share">
	
	  <div data-url="http://jef.binomed.fr/2015/10/30/2015-10-30--Connectez-votre-rameur-d-appartement-avec-Chrome/" data-title="Connectez votre rameur d&#39;appartement avec Chrome | Binomed Blog" data-tsina="null" class="share clearfix">
	  </div>
	
	</div>

</footer>

   	       
	</article>
	
<nav class="article-nav clearfix">
 
 <div class="prev" >
 <a href="/2015/12/11/2015-12-11--myo-sous-linux/" title="Myo sous linux">
  <strong>PREVIOUS:</strong><br/>
  <span>
  Myo sous linux</span>
</a>
</div>


<div class="next">
<a href="/2015/07/07/2015-07-07--Realisez-votre-PortalGun-avec-WebRTC/"  title="Réalisez votre PortalGun avec WebRTC">
 <strong>NEXT:</strong><br/> 
 <span>Réalisez votre PortalGun avec WebRTC
</span>
</a>
</div>

</nav>

	

<section id="comments" class="comment">
  <div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  </div>
</section>

</div>  
      <div class="openaside"><a class="navbutton" href="#" title="Afficher Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Cacher Sidebar"></a></div>
<aside class="clearfix">

  
<div class="categorieslist">
	<p class="asidetitle">Catégories</p>
		<ul>
		
		  
			<li><a href="/categories/Event/" title="Event">Event<sup>5</sup></a></li>
		  
		
		  
			<li><a href="/categories/News/" title="News">News<sup>1</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tech/" title="Tech">Tech<sup>3</sup></a></li>
		  
		
		  
			<li><a href="/categories/Tips/" title="Tips">Tips<sup>1</sup></a></li>
		  
		
		</ul>
</div>


  
<div class="tagslist">
	<p class="asidetitle">Tags</p>
		<ul class="clearfix">
		
			
				<li><a href="/tags/devfest/" title="devfest">devfest<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/myo/" title="myo">myo<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/nodeJS/" title="nodeJS">nodeJS<sup>3</sup></a></li>
			
		
			
				<li><a href="/tags/Canvas/" title="Canvas">Canvas<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/leap-motion/" title="leap motion">leap motion<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/ev3/" title="ev3">ev3<sup>2</sup></a></li>
			
		
			
				<li><a href="/tags/tips/" title="tips">tips<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/HTML5/" title="HTML5">HTML5<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Jeux/" title="Jeux">Jeux<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/WebRTC/" title="WebRTC">WebRTC<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/linux/" title="linux">linux<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/speaker/" title="speaker">speaker<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Angular2/" title="Angular2">Angular2<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/CSS/" title="CSS">CSS<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/PolymerJS/" title="PolymerJS">PolymerJS<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/GDG-Nantes/" title="GDG Nantes">GDG Nantes<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/XDK/" title="XDK">XDK<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Chrome/" title="Chrome">Chrome<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/Arduino/" title="Arduino">Arduino<sup>1</sup></a></li>
			
		
			
				<li><a href="/tags/arduino/" title="arduino">arduino<sup>1</sup></a></li>
			
		
		</ul>
</div>


  <div class="rsspart">
	<a href="/atom.xml" target="_blank" title="rss">RSS</a>
</div>

  <div class="linkslist">
  <p class="asidetitle">Liens</p>
    <ul>
        
          <li>
            
            	<a href="http://gdgnantes.com" target="_blank" title="GDG Nantes">GDG Nantes</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.nantes-wit.fr" target="_blank" title="Nantes Wit">Nantes Wit</a>
            
          </li>
        
          <li>
            
            	<a href="http://www.devoxx4kids.org/france/" target="_blank" title="Devoxx4Kids">Devoxx4Kids</a>
            
          </li>
        
          <li>
            
            	<a href="https://nantescodinggouters.wordpress.com/" target="_blank" title="Coding Goûters">Coding Goûters</a>
            
          </li>
        
          <li>
            
            	<a href="http://jef.binomed.fr/binomed_docs" target="_blank" title="JefBinomed Slides">JefBinomed Slides</a>
            
          </li>
        
          <li>
            
            	<a href="https://devfest.gdgnantes.com" target="_blank" title="DevFest Nantes">DevFest Nantes</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	<div class="line">
		<span></span>
		<div class="author"></div>
	</div>
	
	
	<section class="info">
		<p> Je suis Jean-François Garreau, geek, papa, développeur <br/>
			J&#39;anime aussi le GDG Nantes, Nantes WIT et des Devoxx4Kids</p>
	</section>
	 
	<div class="social-font" class="clearfix">
		
		
		<a href="https://github.com/jefBinomed" target="_blank" class="icon-github" title="github"></a>
		
		
		
		<a href="https://twitter.com/jefBinomed" target="_blank" class="icon-twitter" title="twitter"></a>
		
		
		
		
		
		
		<a href="https://plus.google.com/+JeanFrancoisGarreau?rel=author" target="_blank" class="icon-google_plus" title="Google+"></a>
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2016 
		
		<a href="/about" target="_blank" title="jefBinomed">jefBinomed</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>

<script type="text/javascript">
$(document).ready(function(){ 
  var ai = $('.article-content>iframe'),
      ae = $('.article-content>embed'),
      t  = $('#toc'),
      ta = $('#toc.toc-aside'),
      o  = $('.openaside'),
      c  = $('.closeaside');
  if(ai.length>0){
    ai.wrap('<div class="video-container" />');
  };
  if(ae.length>0){
   ae.wrap('<div class="video-container" />');
  };
  c.click(function(){
    ta.css('display', 'block').addClass('fadeIn');
  });
  o.click(function(){
    ta.css('display', 'none');
  });
  $(window).scroll(function(){
    ta.css("top",Math.max(140,320-$(this).scrollTop()));
  });
});
</script>


<script type="text/javascript">
$(document).ready(function(){ 
  var $this = $('.share'),
      url = $this.attr('data-url'),
      encodedUrl = encodeURIComponent(url),
      title = $this.attr('data-title'),
      tsina = $this.attr('data-tsina'),
      description = $this.attr('description');
  var html = [
  '<div class="hoverqrcode clearfix"></div>',
  '<a href="#" class="overlay" id="qrcode"></a>',
  '<a href="#textlogo" class="article-back-to-top" title="Top"></a>',
  '<a href="https://twitter.com/intent/tweet?url=' + encodedUrl + '" class="article-share-twitter" target="_blank" title="Twitter"></a>',
  '<a href="https://plus.google.com/share?url=' + encodedUrl + '" class="article-share-google_plus" target="_blank" title="Google Plus" onclick="javascript:window.open(this.href,\'\', \'menubar=no,toolbar=no,resizable=yes,scrollbars=yes,height=600,width=600\');return false;" ></a>',
  '<span title="Share to"></span>'
  ].join('');
  $this.append(html);

  $('.hoverqrcode').hide();

  var myWidth = 0;
  function updatehoverqrcode(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
    var qrsize = myWidth > 1024 ? 200:100;
    var options = {render: 'image', size: qrsize, fill: '#2ca6cb', text: url, radius: 0.5, quiet: 1};
    var p = $('.article-share-qrcode').position();
    $('.hoverqrcode').empty().css('width', qrsize).css('height', qrsize)
                          .css('left', p.left-qrsize/2+20).css('top', p.top-qrsize-10)
                          .qrcode(options);
  };
  $(window).resize(function(){
    $('.hoverqrcode').hide();
  });
  $('.article-share-qrcode').click(function(){
    updatehoverqrcode();
    $('.hoverqrcode').toggle();
  });
  $('.article-share-qrcode').hover(function(){}, function(){
      $('.hoverqrcode').hide();
  });
});   
</script>




<script type="text/javascript">

var disqus_shortname = 'binomedblog';

(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
(function(){
  var dsq = document.createElement('script');
  dsq.type = 'text/javascript';
  dsq.async = true;
  dsq.src = '//' + disqus_shortname + '.disqus.com/count.js';
  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
}());
</script>






<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->

<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');
ga('create', 'UA-21310883-4', 'jef.binomed.fr');  
ga('send', 'pageview');
</script>





<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Retour en haut"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
</html>
